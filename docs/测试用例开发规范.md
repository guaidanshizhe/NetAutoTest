# 测试用例开发规范

## 概述

本文档规范了基于AW的测试用例开发标准，确保测试用例的一致性和可维护性。

## 用例开发原则

### 1. 一个文件一个用例
- 每个.py文件对应一个测试用例
- 文件名格式：TC_模块_序号.py
- 类名与文件名保持一致

### 2. 用例信息完整
- 必须填写所有用例信息字段
- 信息要准确、完整、易理解

### 3. 步骤清晰明确
- 测试步骤逻辑清晰
- 每个步骤都有明确的验证
- 使用AW组合实现测试逻辑

## 用例文件结构

### 1. 文件模板
```python
"""
用例功能描述
"""
from framework.base_test import BaseTest

class TC_XXX_001(BaseTest):
    """用例类描述"""
    
    # ========== 用例信息 ==========
    case_id = "TC_XXX_001"
    case_name = "用例名称"
    author = "作者姓名"
    create_date = "创建日期"
    description = "详细描述"
    
    def setup(self):
        """测试前准备"""
        pass
    
    def test_TC_XXX_001(self):
        """测试用例主体"""
        pass
    
    def teardown(self):
        """测试后清理"""
        pass

if __name__ == '__main__':
    import unittest
    unittest.main()
```

### 2. 必需字段说明

#### case_id
- 格式：TC_模块_序号
- 示例：TC_ADN_001, TC_LOGIN_002
- 全局唯一，不可重复

#### case_name
- 简洁描述用例功能
- 中文命名，易于理解
- 长度控制在50字符内

#### author
- 用例开发者姓名
- 便于问题追踪和沟通

#### create_date
- 用例创建日期
- 格式：YYYY-MM-DD

#### description
- 详细的用例描述
- 包含测试目标和预期结果
- 说明测试的业务场景

## 用例开发步骤

### 1. 创建用例文件
```bash
# 复制模板文件
copy testcases\TC_TEMPLATE.py testcases\TC_ADN_001.py
```

### 2. 填写用例信息
```python
class TC_ADN_001(BaseTest):
    case_id = "TC_ADN_001"
    case_name = "ADN服务器连通性测试"
    author = "张三"
    create_date = "2024-01-15"
    description = "验证ADN服务器网络连通性，确保服务正常可访问"
```

### 3. 实现setup方法
```python
def setup(self):
    """测试前准备"""
    # 读取配置
    self.server_ip = "192.168.1.100"
    self.server_port = 8080
    
    # 初始化环境
    self.call_aw("清理测试环境")
    self.call_aw("准备测试数据")
    
    # 建立连接
    result = self.call_aw("连接服务器", ip=self.server_ip)
    self.verify(result, "服务器连接失败")
```

### 4. 实现测试主体
```python
def test_TC_ADN_001(self):
    """测试用例主体"""
    # 步骤1：检查网络连通性
    ping_result = self.call_aw("ping服务器", server_ip=self.server_ip)
    self.verify(ping_result["success"], "服务器ping不通")
    
    # 步骤2：检查端口开放
    port_result = self.call_aw("检查端口开放", 
                              server_ip=self.server_ip, 
                              port=self.server_port)
    self.verify(port_result, f"端口{self.server_port}未开放")
    
    # 步骤3：验证服务响应
    http_result = self.call_aw("检查HTTP服务", 
                              url=f"http://{self.server_ip}:{self.server_port}")
    self.verify_equal(http_result["status_code"], 200, "HTTP服务异常")
```

### 5. 实现teardown方法
```python
def teardown(self):
    """测试后清理"""
    # 清理测试数据
    self.call_aw("清理测试数据")
    
    # 断开连接
    self.call_aw("断开服务器连接")
    
    # 恢复环境
    self.call_aw("恢复初始环境")
```

## AW调用规范

### 1. 调用方式
```python
# 基本调用
result = self.call_aw("AW名称", 参数1="值1", 参数2="值2")

# 带返回值调用
data = self.call_aw("获取系统信息", server_ip="192.168.1.1")
```

### 2. 参数传递
```python
# 位置参数和关键字参数
result = self.call_aw("连接数据库", 
                     host="localhost",
                     port=3306,
                     username="admin",
                     password="123456")

# 使用变量
server_config = {
    "host": "192.168.1.100",
    "port": 22,
    "username": "root"
}
result = self.call_aw("SSH连接", **server_config)
```

## 验证方法使用

### 1. 基础验证
```python
# 布尔验证
self.verify(condition, "验证失败消息")

# 相等验证
self.verify_equal(actual, expected, "值不相等")

# 包含验证
self.verify_contains(container, item, "不包含指定项")
```

### 2. 复杂验证
```python
# 验证返回结果
result = self.call_aw("获取用户信息", user_id=123)
self.verify(result["success"], "获取用户信息失败")
self.verify_equal(result["data"]["name"], "张三", "用户名不匹配")
self.verify_contains(result["data"]["roles"], "admin", "用户权限不足")
```

## 错误处理

### 1. AW调用异常
```python
try:
    result = self.call_aw("可能失败的AW", param="value")
    self.verify(result, "AW执行失败")
except Exception as e:
    self.fail(f"AW调用异常: {str(e)}")
```

### 2. 预期失败处理
```python
# 测试异常场景
with self.assertRaises(ValueError):
    self.call_aw("参数验证AW", invalid_param="")
```

## 数据驱动测试

### 1. 参数化测试
```python
def test_TC_LOGIN_001(self):
    """登录功能测试"""
    test_data = [
        {"username": "admin", "password": "123456", "expected": True},
        {"username": "user", "password": "password", "expected": True},
        {"username": "invalid", "password": "wrong", "expected": False}
    ]
    
    for data in test_data:
        with self.subTest(username=data["username"]):
            result = self.call_aw("用户登录", 
                                username=data["username"],
                                password=data["password"])
            self.verify_equal(result["success"], data["expected"])
```

## 用例命名规范

### 1. 文件命名
- TC_模块_序号.py
- 模块名使用大写英文缩写
- 序号使用3位数字，从001开始

### 2. 类命名
- 与文件名保持一致
- 继承BaseTest类

### 3. 方法命名
- setup(): 测试前准备
- test_用例ID(): 测试主体
- teardown(): 测试后清理

## 注释规范

### 1. 文件注释
```python
"""
用例功能的详细描述
包含测试场景和预期结果
"""
```

### 2. 方法注释
```python
def test_TC_ADN_001(self):
    """
    ADN服务器连通性测试
    验证服务器网络连通性和服务可用性
    """
```

### 3. 步骤注释
```python
# 步骤1：检查网络连通性
ping_result = self.call_aw("ping服务器", server_ip=self.server_ip)

# 步骤2：验证结果
self.verify(ping_result["success"], "网络连通性检查失败")
```

## 用例执行

### 1. 单独执行
```bash
python testcases\TC_ADN_001.py
```

### 2. 批量执行
```bash
python run_tests.py -p "TC_ADN_*.py"
```

### 3. 指定执行
```bash
python run_tests.py -f testcases\TC_ADN_001.py
```

## 最佳实践

### 1. 用例独立性
- 每个用例都能独立执行
- 不依赖其他用例的执行结果
- 有完整的setup和teardown

### 2. 数据隔离
- 使用独立的测试数据
- 避免数据污染
- 及时清理测试数据

### 3. 异常处理
- 预期异常要有明确处理
- 意外异常要记录详细信息
- 确保teardown能正常执行

### 4. 可读性
- 代码逻辑清晰
- 注释详细准确
- 变量命名有意义

### 5. 可维护性
- 避免硬编码
- 使用配置文件
- 模块化设计